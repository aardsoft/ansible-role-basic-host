- name: create networkd configuration directory
  file:
    path: /etc/systemd/network
    owner: root
    group: root
    mode: 0755
    state: directory
  when: network_manager is defined and network_manager == "networkd"
  tags:
    - access_setup

- name: check networkd availability
  service_facts:
  tags:
    - access_setup

- name: install networkd (opensuse, {{distribution_version}})
  zypper:
    name: "systemd-network"
    state: present
  when: >
    ansible_os_family == "Suse" and
    ansible_facts.services["systemd-networkd.service"] is undefined
  tags:
    - access_setup

# link files need a prefix to be evaluated before the 99-default.link
# ideally eventually all networkd configuration files should get migrated to
# this naming scheme
- name: configure network links (networkd)
  template:
    src: systemd-link.j2
    dest: "/etc/systemd/network/{{systemd.networkd_prefix|default(10)}}-{{item.key}}.link"
    mode: 0644
  with_dict: "{{network_nodes[inventory_hostname].networks |default({})}}"
  when: >
    network_manager is defined and network_manager == "networkd" and
    item.value.link_flags is defined and
    (item.value.manager is undefined or item.value.manager == "networkd") and
    item.key != "ilo"
  notify:
    - restart networkd
  tags:
    - access_setup

- name: configure virtual network devices (networkd)
  template:
    src: systemd-netdev.j2
    dest: "/etc/systemd/network/{{item.key}}.netdev"
    mode: 0644
  with_dict: "{{network_nodes[inventory_hostname].networks |default({})}}"
  when: >
    network_manager is defined and network_manager == "networkd" and
    item.value.type is defined and item.value.type != "phys" and
    (item.value.manager is undefined or item.value.manager == "networkd") and
    item.key != "ilo" and item.value.type != "veth"
  notify:
    - restart networkd
  tags:
    - access_setup

- name: configure static network interfaces (networkd)
  template:
   src: systemd-network.j2
   dest: "/etc/systemd/network/{{item.key}}.network"
   mode: 0644
  with_dict: "{{network_nodes[inventory_hostname].networks |default({})}}"
  when: >
    network_manager is defined and network_manager == "networkd" and
    (item.value.manager is undefined or item.value.manager == "networkd") and
    item.key != "ilo"
  notify:
    - restart networkd
  tags:
    - access_setup

- name: enable networkd services
  systemd: name="{{item}}" enabled=yes force=yes
  with_items:
    - systemd-networkd
    - systemd-networkd-wait-online
  when: network_manager is defined and network_manager == "networkd"
  notify:
    - restart networkd
  tags:
    - access_setup

- name: disable network manager services
  service: name="{{item}}" enabled=no state=stopped
  with_items:
    - NetworkManager
    - NetworkManager-wait-online
  when: network_manager is defined and network_manager != "networkmanager"
  tags:
    - access_setup
  ignore_errors: True

- name: enable network manager services
  service: name="{{item}}" enabled=yes state=started
  with_items:
    - NetworkManager
    - NetworkManager-wait-online
  when: network_manager is defined and network_manager == "networkmanager"
  tags:
    - access_setup

- name: locate old ifcfg files
  find:
    paths: /etc/sysconfig/network-scripts/
    patterns: "ifcfg-e*"
    recurse: no
    file_type: file
  register: find_result
  when: >
    network_manager is defined and network_manager == "networkd"

- name: remove old ifcfg files
  file:
    state: absent
    path: "{{ item.path }}"
  with_items: "{{ find_result.files }}"
  when: >
    network_manager is defined and network_manager == "networkd"

- name: configure wireguard interfaces
  include: manage_wireguard.yml
  with_dict: "{{network_nodes[inventory_hostname].networks |default({})}}"
  loop_control:
    loop_var: _iface
  when: >
    _iface.value.manager is defined and _iface.value.manager == "wg" and
    wireguard is defined and wireguard[_iface.key] is defined
  tags:
    - access_setup

# this seems to go mostly away, so relying on distributions no longer
# works. Only disable when explicitely required.
- name: remove bridge filtering keys on unsupported distributions
  sysctl:
    name: "{{ item }}"
    state: absent
    reload: yes
  with_items:
    - net.bridge.bridge-nf-call-ip6tables
    - net.bridge.bridge-nf-call-iptables
    - net.bridge.bridge-nf-call-arptables
  when: >
    bridge_filtering is undefined or bridge_filtering == false
  ignore_errors: True

# having this enabled randomly breaks connectivity over bridges
- name: disable filtering on bridges
  sysctl:
    name: "{{ item }}"
    value: 0
    sysctl_set: yes
    state: present
    reload: yes
  with_items:
    - net.bridge.bridge-nf-call-ip6tables
    - net.bridge.bridge-nf-call-iptables
    - net.bridge.bridge-nf-call-arptables
  when: >
    bridge_filtering is defined and bridge_filtering == true
- set_fact:
    is_wsl: True
  when: ansible_kernel is search("Microsoft")

- name: check provisioning marker
  stat:
    path: "/.provisioning-needed"
  register: marker

- name: configure root user password
  user:
    name: root
    password: "{{lookup(passdb, root_passdb_entry)|password_hash('sha512', 65534 | random(seed=inventory_hostname) | string)}}"
  when: >
    root_passdb_entry is defined

- name: set sudo package name
  set_fact:
    sudo_pkg: "sudo"
  tags:
    - base_config
    - access_setup

- name: set sudo package name for Debian
  set_fact:
    sudo_pkg: "sudo-ldap"
  when: ansible_distribution == 'Debian'
  tags:
    - base_config
    - access_setup

- name: set resolv location to site, if necessary
  tags:
    - base_config
    - access_setup
  set_fact:
    resolv_location: "{{ site_region }}"
  when: site_region is defined and resolv_location is undefined

- name: add resolv.conf
  tags:
    - base_config
  copy:
    src: resolv.conf.{{ resolv_location }}
    dest: /etc/resolv.conf
    owner: root
    group: root
    mode: 0644
  when: resolv_location is defined

- name: add resolv.conf (template)
  tags:
    - base_config
  template:
    src: resolv.conf.j2
    dest: /etc/resolv.conf
    owner: root
    group: root
    mode: 0644
  when: nameservers is defined

- name: add adjtime
  copy:
    src: adjtime
    dest: /etc/adjtime
    owner: root
    group: root
    mode: 0644
  tags:
    - base_config

- name: add hosts
  template:
    src: hosts.j2
    dest: /etc/hosts
    owner: root
    group: root
    mode: 0644
  tags:
    - base_config

- name: add environment
  template:
    src: environment.j2
    dest: /etc/environment
    owner: root
    group: root
    mode: 0644
  tags:
    - base_config

- name: add logind configuration
  template:
    src: logind.conf.j2
    dest: /etc/systemd/logind.conf
    owner: root
    group: root
    mode: 0644
  tags:
    - base_config
  notify:
    - restart logind
  when: ansible_service_mgr == 'systemd'

- name: add journald configuration
  template:
    src: journald.conf.j2
    dest: /etc/systemd/journald.conf
    owner: root
    group: root
    mode: 0644
  tags:
    - base_config
  notify:
    - restart journald
  when: ansible_service_mgr == 'systemd'

- name: locate existing sshd host keys
  find:
    paths: /etc/ssh/
    patterns: "ssh_host_*_key"
    recurse: no
    file_type: file
  register: ssh_host_keys
  tags:
    - base_config

- name: add sshd configuration
  template:
    src: sshd_config.j2
    dest: /etc/ssh/sshd_config
    owner: root
    group: root
    mode: 0640
  tags:
    - base_config
  notify:
    - restart sshd

# timezone command was added in 2.2 only
- name: set /etc/timezone
  copy:
    content: "{{ host_timezone }}"
    dest: /etc/timezone
  tags:
    - base_config

- name: set /etc/localtime
  file:
    src: "/usr/share/zoneinfo/{{ host_timezone }}"
    dest: /etc/localtime
    state: link
    force: yes
  tags:
    - base_config

- stat: path=/etc/hostname
  register: hostname_file
  tags:
    - base_config

- name: set hostname
  copy:
    content: "{{ hostname }}"
    dest: /etc/hostname
  when: hostname.stat.exists == False and hostname is defined

- name: set hostname
  copy:
    content: "{{ inventory_hostname.split('.')[0] }}"
    dest: /etc/hostname
  when: hostname.stat.exists == False and hostname is undefined
  tags:
    - base_config

- include_tasks: debug_variables.yml
  when: debug_variables is defined and debug_variables == True
  tags:
    - base_config
    - access_setup

- include_tasks: "basic_host_{{ ansible_os_family }}.yml"
  when: ansible_os_family == "Debian" or ansible_os_family == "Suse" or ansible_os_family == "RedHat"
  tags:
    - base_config
    - access_setup

- name: create ssl cert group
  group: name=ssl-cert gid=950 state=present

- name: create certificate directory
  file:
    path: /etc/ssl/keys
    owner: root
    group: ssl-cert
    mode: 0750
    state: directory

# This supports a structure similar to:
#
# secret_files:
#   ceph_mirrors:
#     dest: /etc/ceph/frontend_mirrors.secret
#     key: ceph/frontend_mirrors
- name: add secret files
  template:
    src: secretfile.j2
    dest: "{{item.value.dest}}"
    owner: "{{item.value.owner|default('root')}}"
    group: "{{item.value.group|default('root')}}"
    mode: "{{item.value.mode|default(0400)}}"
  with_dict: "{{secret_files|default({})}}"
  when: >
    item.value.dest is defined and
    item.value.key is defined and
    (item.value.state is undefined or
     (item.value.state is defined and item.value.state != "absent"))

#- name: Install python-selinux (Suse)
#  zypper:
#    name: "python-selinux"
#    state: present
#  when: ansible_os_family == "Suse"
#  tags:
#    - access_setup

# This is split off to allow easier includes from roles using delegates
- include: manage_adm_user.yml

- name: copy scripts
  copy:
    src: "{{item}}"
    dest: /usr/bin/{{item}}
    owner: root
    group: root
    mode: 0755
  with_items:
    - hp-spp-tool

- name: create networkd configuration directory
  file:
    path: /etc/systemd/network
    owner: root
    group: root
    mode: 0755
    state: directory
  when: network_manager is defined and network_manager == "networkd"
  tags:
    - access_setup

- name: configure virtual network devices (networkd)
  template:
    src: systemd-netdev.j2
    dest: "/etc/systemd/network/{{item.key}}.netdev"
    mode: 0644
  with_dict: "{{network_nodes[inventory_hostname].networks |default({})}}"
  when: >
    network_manager is defined and network_manager == "networkd" and
    item.value.type is defined and item.value.type != "phys" and
    (item.value.manager is undefined or item.value.manager == "networkd") and
    item.key != "ilo" and item.value.type != "veth"
  notify:
    - restart networkd
  tags:
    - access_setup

- name: configure static network interfaces (networkd)
  template:
   src: systemd-network.j2
   dest: "/etc/systemd/network/{{item.key}}.network"
   mode: 0644
  with_dict: "{{network_nodes[inventory_hostname].networks |default({})}}"
  when: >
    network_manager is defined and network_manager == "networkd" and
    (item.value.manager is undefined or item.value.manager == "networkd") and
    item.key != "ilo"
  notify:
    - restart networkd
  tags:
    - access_setup

- name: enable networkd services
  service: name="{{item}}" enabled=yes
  with_items:
    - systemd-networkd
    - systemd-networkd-wait-online
  when: network_manager is defined and network_manager == "networkd"
  notify:
    - restart networkd
  tags:
    - access_setup

- name: enable network manager services
  service: name="{{item}}" enabled=yes state=started
  with_items:
    - NetworkManager
    - NetworkManager-wait-online
  when: network_manager is defined and network_manager == "networkmanager"
  tags:
    - access_setup

- name: locate old ifcfg files
  find:
    paths: /etc/sysconfig/network-scripts/
    patterns: "ifcfg-e*"
    recurse: no
    file_type: file
  register: find_result
  when: >
    network_manager is defined and network_manager == "networkd"

- name: remove old ifcfg files
  file:
    state: absent
    path: "{{ item.path }}"
  with_items: "{{ find_result.files }}"
  when: >
    network_manager is defined and network_manager == "networkd"

# this seems to go mostly away, so relying on distributions no longer
# works. Only disable when explicitely required.
- name: remove bridge filtering keys on unsupported distributions
  sysctl:
    name: "{{ item }}"
    state: absent
    reload: yes
  with_items:
    - net.bridge.bridge-nf-call-ip6tables
    - net.bridge.bridge-nf-call-iptables
    - net.bridge.bridge-nf-call-arptables
  when: >
    bridge_filtering is undefined or bridge_filtering == false
  ignore_errors: True

# having this enabled randomly breaks connectivity over bridges
- name: disable filtering on bridges
  sysctl:
    name: "{{ item }}"
    value: 0
    sysctl_set: yes
    state: present
    reload: yes
  with_items:
    - net.bridge.bridge-nf-call-ip6tables
    - net.bridge.bridge-nf-call-iptables
    - net.bridge.bridge-nf-call-arptables
  when: >
    bridge_filtering is defined and bridge_filtering == true

- name: check if firewalld is available and working
  firewalld:
    zone: block
    state: enabled
    permanent: no
  register: firewalld_result
  ignore_errors: True

- name: register firewalld status
  set_fact:
    firewalld_available: True
  when: firewalld_result is succeeded

- name: setup firewalld
  include: firewalld_setup.yml
  when: >
    firewalld_available == False and
    firewalld_required is defined and firewalld_required == True

- name: create additional firewalld zones
  firewalld:
    zone: "{{__zone}}"
    state: present
    permanent: yes
  loop_control:
    loop_var: __zone
  with_items: "{{firewalld_zones}}"
  register: __zones_changed
  when: >
    firewalld_available == True and
    firewalld_zones is defined and
    (__zone.state is undefined or
    __zone.state == "present")

- debug: msg="{{__zones_changed}}"

- name: reload firewalld
  systemd:
    name: firewalld
    state: reloaded
  when: >
    __zones_changed is defined and
    __zones_changed is changed

- name: configure firewalld zones for networkd managed interfaces
  firewalld:
    zone: "{{ item.value.zone }}"
    interface: "{{ item.key }}"
    permanent: true
    state: enabled
    immediate: true
  with_dict: "{{network_nodes[inventory_hostname].networks |default({})}}"
  when: >
    firewalld_available == True and
    item.value.zone is defined
  tags:
    - access_setup

- name: configure firewalld rules
  include: firewalld_rules.yml
  with_dict: "{{firewalld_rules}}"
  when: >
    firewalld_available == True and firewalld_rules is defined

- name: copy selinux configuration
  template:
    src: selinux.config.j2
    dest: /etc/selinux/config
    owner: root
    group: root
    mode: 0644
  when: ansible_os_family == "RedHat"

# to generate te files, use audit2allow against audit.log
# as example: cat /var/log/audit/audit.log | audit2allow -m nginx > nginx.te
# or, in case there's already a module which should not be overriden, create
# using a different name:
# grep ctdb /var/log/audit/audit.log | audit2allow -M ctdb-ceph
- name: add custom selinux modules
  include: add_selinux_modules.yml
  with_dict: "{{selinux_te_files|default({})}}"
  when: >
    (item.value.state is undefined or
     (item.value.state is defined and item.value.state != "absent"))

- name: remove custom selinux modules
  command: "semodule -r {{item.key}}"
  with_dict: "{{selinux_te_files|default({})}}"
  when: >
    item.value.state is defined and item.value.state == "absent"

- name: drop root .ssh (provisioning)
  file:
    path: "/root/.ssh"
    state: absent
  when: marker.stat.exists == True

- name: drop provisioning marker
  file:
    path: "/.provisioning-needed"
    state: absent
  when: marker.stat.exists == True

# non-provisioning related steps should go here, if possible

- name: create systemd timers
  include_tasks: systemd_timer.yml
  when: systemd_timers is defined

- name: manage users
  include_tasks: manage_users.yml
  tags:
    - base_config
    - access_setup